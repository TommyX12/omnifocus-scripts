/*{
  "type": "action",
  "targets": ["omnifocus"],
  "author": "TommyX",
  "identifier": "com.tommyx.cfs",
  "version": "1.0",
  "description": "Completely-Fair Scheduling",
  "label": "Completely-Fair Scheduling",
  "paletteLabel": "CFS"
  }*/

(() => {
    let getQueuesFolder = () => folders.byName("Queues Test")

    let stringParser = value => value

    let floatParser = (value) => {
        let result = parseFloat(value)
        if (isNaN(result)) {
            return undefined
        }
        return result
    }

    let boolParser = (value) => {
        return value.trim() === "true"
    }

    let parsers = {
        weight: floatParser,
        isContainerOnly: boolParser,
        useCFS: boolParser,
    }

    let isTaskActionable = (taskStatus) => {
        return taskStatus === Task.Status.Available ||
                taskStatus === Task.Status.DueSoon ||
                taskStatus === Task.Status.Next ||
                taskStatus === Task.Status.Overdue
    }

    let isTaskCompletedOrDropped = (taskStatus) => {
        return taskStatus === Task.Status.Completed ||
                taskStatus === Task.Status.Dropped
    }

    let parseTaskParams = (task) => {
        let params = {
            weight: 1,
            isContainerOnly: false,
            useCFS: false,
        }

        let note = task.note
        let lineBreakIndex = note.indexOf("\n")
        if (lineBreakIndex >= 0) {
            note = note.substring(0, lineBreakIndex)
        }
        for (let p of note.split(",")) {
            let match = p.match(/\b(\w+)\s*:\s*(\S+)\b/)
            if (match) {
                let key = match[1]
                let value = match[2]
                if (parsers[key] === undefined) {
                    continue
                }
                value = parsers[key](value)
                if (value === undefined) {
                    continue
                }
                params[key] = value
            }
        }
        return params
    }

    let isUsingCFS = (task, queuesFolder, taskParams) => {
        if (!task) return false

        if (!queuesFolder) queuesFolder = getQueuesFolder()

        if (task instanceof Folder) {
            return queuesFolder == task
        }
        if (!taskParams) {
            taskParams = parseTaskParams(task)
        }
        return taskParams.useCFS
    }

    let getSelectedTasks = (selection) => {
        let selected = []
        for (let task of selection.projects) {
            selected.push(task)
        }
        for (let task of selection.tasks) {
            selected.push(task)
        }
        return selected
    }

    let getParent = (task) => {
        if (task instanceof Project) {
            return task.parentFolder
        }
        if (task instanceof Task) {
            let result = task.parent
            if (result && result.project) return result.project
            return result
        }
        return undefined
    }

    let action = new PlugIn.Action(function(selection, sender) {
        let queuesFolder = getQueuesFolder()

        let isActive = (task, taskParams) => {
            if (isTaskCompletedOrDropped(task)) {
                console.log(`${task.name} is completed or dropped`)
                return false
            }

            let hasAvailableChildren = false
            if (task instanceof Project && !task.containsSingletonActions) {
                hasAvailableChildren = task.nextTask && task.nextTask != task.task
            } else {
                hasAvailableChildren = task.children.some(child => {
                    return isTaskActionable(child.taskStatus)
                })
            }

            if (hasAvailableChildren) {
                return true
            }

            let isSelfAvailable = false
            if (!taskParams.isContainerOnly) {
                isSelfAvailable = isTaskActionable(task.taskStatus)
            }
            return isSelfAvailable
        }

        let logWork = (task, duration, siblings) => {
            let taskParams = parseTaskParams(task)
            let siblingParams = siblings.map(parseTaskParams)

            let runtime = task.estimatedMinutes || 1
            let weight = taskParams.weight
            let delta = Math.ceil(duration / weight)
            task.estimatedMinutes = runtime + delta

            // normalization

            // find min runtime of active tasks
            let minRuntime = -1
            for (let i = 0; i < siblings.length; ++i) {
                let t = siblings[i]
                let tParams = siblingParams[i]
                let runtime = t.estimatedMinutes || 1
                if ((t == task || isActive(t, tParams))
                    && (minRuntime === -1 || runtime < minRuntime)) {
                    minRuntime = runtime
                }
            }
            // inactive tasks gets moved along with the current task, bounded by min runtime of active tasks
            for (let i = 0; i < siblings.length; ++i) {
                let t = siblings[i]
                let tParams = siblingParams[i]
                let runtime = t.estimatedMinutes || 1
                if (t != task && !isActive(t, tParams)) {
                    t.estimatedMinutes = Math.max(runtime, Math.min(minRuntime, runtime + delta))
                }
            }
            // now find min runtime of all tasks
            minRuntime = -1
            for (let i = 0; i < siblings.length; ++i) {
                let t = siblings[i]
                let tParams = siblingParams[i]
                let runtime = t.estimatedMinutes || 1
                if (minRuntime === -1 || runtime < minRuntime) {
                    minRuntime = runtime
                }
            }
            // normalizes so that their minimum becomes 1
            if (minRuntime !== -1) {
                let delta = minRuntime - 1
                for (let i = 0; i < siblings.length; ++i) {
                    let t = siblings[i]
                    let tParams = siblingParams[i]
                    let runtime = t.estimatedMinutes || 1
                    t.estimatedMinutes = Math.max(1, runtime - delta)
                }
            }
        }

        let inputForm = new Form()
        let dateFormat = Formatter.Date.Style.Short
        let dateFormatter = Formatter.Date.withStyle(dateFormat, dateFormat)

        let durationField = new Form.Field.String(
            "duration",
            "Duration (hours)",
            "0.5"
        )

        inputForm.addField(durationField)

        let formPromise = inputForm.show("Enter duration", "Continue")

        inputForm.validate = function(formObject){
            let duration = parseFloat(formObject.values["duration"])
            return !isNaN(duration) && duration >= 0
        }

        formPromise.then(function(formObject){
            try {
                let task = getSelectedTasks(selection)[0]
                let parent = getParent(task)
                while (parent) {
                    if (isUsingCFS(parent, queuesFolder)) {
                        let isFolder = parent instanceof Folder
                        logWork(
                            task,
                            Math.round(parseFloat(formObject.values["duration"]) * 60),
                            isFolder ? parent.projects : parent.children)

                        if (!isFolder) {
                            // sort siblings
                            let siblings = parent.children.filter(
                                task => !isTaskCompletedOrDropped(task.taskStatus))
                            siblings.sort((a, b) => {
                                a = a.estimatedMinutes || 1
                                b = b.estimatedMinutes || 1
                                return a - b
                            })
                            moveTasks(siblings, parent)
                        }
                    }
                    task = parent
                    parent = getParent(parent)
                }
            }
            catch(err){
                console.error(err)
            }
        })

        formPromise.catch(function(err){
            console.log("form cancelled", err.message)
        })
    });

    action.validate = function(selection, sender) {
        let queuesFolder = getQueuesFolder()
        if (!queuesFolder) return false;

        let selected = getSelectedTasks(selection)
        if (selected.length !== 1) return false;

        let task = selected[0]

        let parent = getParent(task)
        while (parent) {
            if (!isUsingCFS(parent, queuesFolder)) return false
            if (parent == queuesFolder) return true
            task = parent
            parent = getParent(parent)
        }

        return false
    };

    return action;
})();
