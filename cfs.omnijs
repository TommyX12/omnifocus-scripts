/*{
  "type": "action",
  "targets": ["omnifocus"],
  "author": "TommyX",
  "identifier": "com.tommyx.cfs",
  "version": "1.0",
  "description": "Completely-Fair Scheduling",
  "label": "Completely-Fair Scheduling",
  "paletteLabel": "CFS"
  }*/

(() => {
    let getQueuesFolder = () => folders.byName("Queues")

    let isActive = t => t.nextTask && t.nextTask != t.task

    let work = (task, duration) => {
        let queuesFolder = getQueuesFolder()
        for (let t of queuesFolder.projects) {
            if (t.containsSingletonActions) {
                new Alert("Invalid project", "Project with singleton actions is not supported").show()
                return
            }
        }

        let runtime = task.estimatedMinutes || 1
        let match = task.note.match(/\bweight: ([.0-9]+)\b/)
        let weight = (match && parseFloat(match[1])) || 1
        if (weight <= 0) weight = 1
        let delta = Math.ceil(duration / weight)
        task.estimatedMinutes = runtime + delta

        // normalization

        // find min runtime of active tasks
        let minRuntime = -1
        for (let t of queuesFolder.projects) {
            let runtime = t.estimatedMinutes || 1
            if ((t == task || isActive(t))
                && (minRuntime === -1 || runtime < minRuntime)) {
                minRuntime = runtime
            }
        }
        // inactive tasks gets moved along with the current task, bounded by min runtime of active tasks
        for (let t of queuesFolder.projects) {
            let runtime = t.estimatedMinutes || 1
            if (t != task && !isActive(t)) {
                t.estimatedMinutes = Math.min(minRuntime, runtime + delta)
            }
        }
        // now find min runtime of all tasks
        minRuntime = -1
        for (let t of queuesFolder.projects) {
            let runtime = t.estimatedMinutes || 1
            if (minRuntime === -1 || runtime < minRuntime) {
                minRuntime = runtime
            }
        }
        // normalizes so that their minimum becomes 1
        if (minRuntime !== -1) {
            let delta = minRuntime - 1
            for (let t of queuesFolder.projects) {
                let runtime = t.estimatedMinutes || 1
                t.estimatedMinutes = Math.max(1, runtime - delta)
            }
        }
    }

    let action = new PlugIn.Action(function(selection, sender) {
        let inputForm = new Form()
        let dateFormat = Formatter.Date.Style.Short
        let dateFormatter = Formatter.Date.withStyle(dateFormat, dateFormat)

        let durationField = new Form.Field.String(
            "duration",
            "Duration (hours)",
            "0.5"
        )

        inputForm.addField(durationField)

        let formPromise = inputForm.show("Enter duration", "Continue")

        inputForm.validate = function(formObject){
            let duration = parseFloat(formObject.values["duration"])
            return !isNaN(duration) && duration >= 0
        }

        formPromise.then(function(formObject){
            try {
                let selected = undefined
                for (let task of selection.projects) {
                    selected = task
                }
                for (let task of selection.tasks) {
                    selected = task
                }
                work(selected, Math.round(parseFloat(formObject.values["duration"]) * 60))
            }
            catch(err){
                console.error(err)
            }
        })

        formPromise.catch(function(err){
            console.log("form cancelled", err.message)
        })
    });

    action.validate = function(selection, sender) {
        let queuesFolder = getQueuesFolder()
        if (!queuesFolder) return false;

        if (!selection.projects || selection.projects.length !== 1) return false;

        let selected = selection.projects[0]
        return selected.parentFolder == queuesFolder
    };

    return action;
})();
